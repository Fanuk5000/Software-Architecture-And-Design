## Лабораторна 1, Варіант 9

### Завдання:

Розробити застосування, яке симулює процес гри в настільну гру: монополія, мафія, alias. Для
гри може бути потрібно: ігрове поле, кубики, фішки, картки. Без одного із необхідних
компонентів у гру грати неможливо. При цьому «зайвих» компонентів теж не повинно бути.
Гру неможливо почати доки всі гравці не познайомляться з правилами. За хід гравець може
посунути фішку, щось купити чи продати, виконати певну дію по завданню (але тільки одну
дію, якщо протилежне не вказане в інструкції). Грати можна тільки по черзі (тобто, хід робить
саме той гравець, хто є наступним). Передбачити, що грати можна вдвох чи з більшою
кількістю гравців. В іншому випадку гру почати неможливо. Одночасно зробити хід кілька
гравців не можуть. Передбачити можливість, що будуть додаватися ігри в, які можуть грати
тільки 2 гравці (наприклад, шашки), а також вводитися додаткові компоненти гри (наприклад,
додаткові картки). Гра триває доти, доки хтось із гравців не виграє (якщо інше не
передбачається правилами). Додати можливість задавати параметри гри правилами (ігрові
компоненти, гравці, дії під час ходу).

### Структура лабораторної

```
├── Entities
│ ├── boards
│ │ ├── alias.py
│ │ ├── board.py
│ │ ├── **init**.py
│ │ ├── mafia.py
│ │ └── monopoly.py
│ ├── game_components.py
│ ├── **init**.py
│ ├── player.py
│ └── team.py
├── GameLogics
│ ├── alias.py
│ ├── factories.py
│ ├── general.py
│ ├── **init**.py
│ ├── mafia.py
│ └── monopoly.py
├── main.py
├── my_diagram.png
├── task.md
└── UI
├── **init**.py
└── menu.py
```

- **Entities** містить сутності для взаємодії

- **GameLogics** містить логіку та фабрики для створення сутностей та інших об'єктів

- **UI** тримає усе що пов'язано з виведенням у термінал та зв'язуванням сутностей та логіки

### Запуск

- Клонуйте репозиторій у бажане місце:

```
git clone https://github.com/Fanuk5000/Software-Architecture-And-Design.git
```

- Потім перейдіть у нього та директорію з Першою лабораторною

```
cd Lab1
```

- Для запуску прописуємо:

```
python main.py
```

### Відповіді на контрольні питання

1.  Основні принципи OOP (Загальний огляд)

    **Особливості:** Базується на 4 стовпах: Інкапсуляція (приховування даних), Наслідування (перевикористання коду), Поліморфізм (один інтерфейс — багато реалізацій), Абстракція (виділення головного).

    **Проблеми:** Створення занадто складних ієрархій ("спагеті-код" об'єктів), надмірне використання пам'яті, складність у тестуванні через жорсткі зв'язки.

    **Рішення:** Використання патернів проектування (GoF), дотримання принципів SOLID, надання переваги композиції над наслідуванням.

2.  Абстракція

    **Що це:** Метод виділення значущих характеристик об'єкта, відкидаючи незначні деталі реалізації.

    **Що дає:** Дозволяє керувати складністю системи, розділяючи інтерфейс (що робить) та реалізацію (як робить).

    **Де і коли:** Використовується на етапі проектування архітектури, при створенні бібліотек/API. Варто застосовувати, коли є ймовірність зміни логіки в майбутньому, щоб не переписувати клієнтський код.

3.  Single Responsibility Principle (SRP)

    **Особливості:** Клас повинен мати лише одну причину для змін. Він має відповідати за одну частину функціоналу.

    **Проблеми**: Поява "God Object" (об'єктів, що знають і вміють все). Зміна однієї функції ламає іншу, непов'язану.

    **Рішення:** Розділення великих класів на менші, делегування обов'язків.

4.  Open-Closed Principle (OCP)

    **Особливості:** Програмні сутності мають бути відкриті для розширення, але закриті для модифікації.

    **Проблеми:** Якщо для додавання нової функції доводиться змінювати існуючий протестований код, це вносить нові баги (регресію).

    **Рішення:** Використання інтерфейсів та наслідування/поліморфізму. Патерн "Стратегія". Замість if-else блоків — поліморфний виклик.

5.  Liskov Substitution Principle (LSP)

    **Особливості:** Об'єкти підкласів повинні замінювати об'єкти батьківських класів без порушення роботи програми.

    **Проблеми**: Підклас порушує контракт батька (наприклад, кидає виключення там, де батько цього не робив, або змінює очікуваний результат).

    **Рішення:** Проектування за контрактом. Не створювати фіктивних реалізацій методів у спадкоємцях.

6.  Interface Segregation Principle (ISP)

    **Особливості:** Клієнти не повинні залежати від інтерфейсів, які вони не використовують. Краще багато вузькоспеціалізованих інтерфейсів, ніж один загальний.

    **Проблеми:** Клас змушений реалізовувати методи, які йому не потрібні (залишаючи їх пустими або з помилками). Будь-яка зміна в "жирному" інтерфейсі впливає на всіх клієнтів.

    **Рішення:** Декомпозиція інтерфейсів. Використання патерну "Адаптер", якщо не можна змінити вихідний код.

7.  Dependency Inversion Principle (DIP)

    **Особливості:** Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Обидва повинні залежати від абстракцій. Абстракції не повинні залежати від деталей.

    **Проблеми:** Жорсткий зв'язок (tight coupling). Неможливість юніт-тестування (не можна підмінити базу даних на мок-об'єкт).

    **Рішення:** Dependency Injection (впровадження залежностей), використання IoC-контейнерів, робота через інтерфейси.

8.  Абстрактний клас vs Інтерфейс

    **Абстрактний клас:** Може містити стан (поля), конструктори та часткову реалізацію методів. Відповідає на питання "Хто це?" (Is-a). Підтримує лише одиничне наслідування (у більшості мов, як C# чи Java).

    **Інтерфейс:** Тільки контракт (сигнатури методів), без стану (хоча в C# 8.0+ з'явились дефолтні реалізації). Відповідає на питання "Що вміє робити?" (Can-do). Підтримує множинну реалізацію.

9.  DRY, YAGNI, KISS

    **DRY** (Don't Repeat Yourself): Уникайте дублювання коду.

         Проблема: Зміна логіки вимагає правок у багатьох місцях.

         Рішення: Винесення спільної логіки у функції або базові класи.

    **YAGNI** (You Ain't Gonna Need It): Не пишіть код "на майбутнє".

         Проблема: Оверинжиніринг, витрата часу на те, що не знадобиться.

         Рішення: Реалізовувати тільки поточні вимоги.

    **KISS** (Keep It Simple, Stupid): Робіть код максимально простим.

         Проблема: Складний код важко читати та підтримувати.

         Рішення: Уникати хитромудрих конструкцій, розбивати складне на просте.

10. Cohesion (Згуртованість) та Coupling (Зв'язність)

    **Cohesion**: Міра того, наскільки методи класу логічно пов'язані між собою.

        Мета: High Cohesion (Висока згуртованість). Клас робить одну зрозумілу річ.

    **Coupling**: Міра залежності одного класу від інших.

        Мета: Low Coupling (Низька зв'язність). Зміни в одному модулі не повинні ламати інші.

    Типові рішення: Використання DI, інтерфейсів, інкапсуляція.

11. Inheritance with caution (Наслідування з обережністю)

    **Особливості**: Наслідування створює найсильніший зв'язок між класами.

    **Проблеми**: Проблема "крихкого базового класу" (зміна батька ламає дітей). Глибока ієрархія стає некерованою.

    **Коли наслідування:** Тільки для чіткого відношення "Is-a" (Собака Є Твариною) і для повторного використання коду батька.

    **Коли композиція:** Для відношення "Has-a" (Автомобіль МАЄ Двигун). Композиція гнучкіша, дозволяє динамічно змінювати поведінку. Принцип: Composition over Inheritance.

12. Основні питання при проектуванні ПЗ

Яку проблему ми вирішуємо?

    Хто користувач?

    Які вимоги до навантаження та масштабування?

    Наскільки легко буде підтримувати та розширювати систему?

    Які обмеження (бюджет, час, технології)?

13. Практики проектування

    **TDD (Test Driven Development):** Спочатку тест, потім код.

    **DDD (Domain Driven Design):** Проектування від предметної області.

    **CI/CD:** Безперервна інтеграція та доставка.

    **Code Review:** Перевірка коду колегами.

    **Design Patterns:** Використання перевірених архітектурних рішень.

14. Code Standards та Code Conventions (C#)

    Для чого: Забезпечують читабельність, однаковість стилю в команді, полегшують онбординг новачків та рев'ю коду.

    Для C# (Microsoft Guidelines):

        PascalCase: Для назв класів, методів, властивостей, public полів (UserService, GetId).

        camelCase: Для локальних змінних та параметрів методів (userId, isValid).

        Інтерфейси: Починаються з I (IRepository).

        Фігурні дужки: Кожна дужка { та } на новому рядку (на відміну від Java/JS).

15. Duck Behavior (Качина типізація)

    **Що це:** "Якщо щось ходить як качка і крякає як качка, то це качка". Тип об'єкта визначається не його класом, а наявністю необхідних методів/властивостей у момент виконання.

    Де використовується: Основний принцип у динамічних мовах (Python, JavaScript). У статичних мовах (C#) це реалізується через ключове слово dynamic або (більш безпечно та правильно архітектурно) через поліморфізм інтерфейсів.
